Phase 1:
=========
1. Writing Hexidecimal 
2. The Magic Boot Number
3. Writing a valid bootloader in Hex
4. Experiment writing valid bootloader in ASM (traslate Hex -> ASM)
5. Ambitious: Look at printing data

Phase 2:
=========
1. Introduction to the ASM bootloader, inspect HEX
2. Data vs. Code in Binary files..
3. Defining data in ASM
4. Introduction to Interrupts & BIOS calls
5. Stack

Phase 3:
========
1. What does the 1st stage bootloader need to do?
2. Understanding Memory addressing and limitations.
3. Defining a memory map for the inital bootloader and Kernel
4. Using BIOS to read data from a disk to disk buffer
5. Reading that new sector

Phase 4:
========
1. Get stage02 loaded from the disk and successfully jump to it
2. After we get there, detect low memory that is available
3. Then multiple calls to e820 for high memory. 
4. ....

Phase 5:
========
1. Writing to a file in Bochs/Qemu. 
2. Setting up the serial ports.
3. Writing bytes to the serial port in a single call.
4. Constructing a serial_print_string method. 
5. Enabling the A20 line to prepare for PMode.

Phase 6:
========
1. Taking a step back. Difference between HDD and FDisk.
2. Reading a sector from a HDD.
3. CHS and LBA
4. Combining all of this to the new Stage01 loader (will load
   both HDD and Fdisk, choosing correctly and storing drive).

Phase 7:
========
1. Using the Stack to call functions in ASM.
2. Difference between register and stack calling.
3. Refactoring bootsector (1 and 2) to use stack. 
4. Setting up the GDT for PMode.

Phase 8:
========
1. Loading the Kernel from disk to memory (stage02).
2. Setting up PMode for the kernel.
3. Jump to kernel.    

;===========================================================================;
;	Note for FINAL VERSION of BOOTLOADER:									;
;	It's common for the loader to keep interrupts 							;
;	disabled (the kernel will enable them later when an IDT is properly 	;
;	set up).																;
;																			;
;	Take time to think about whether or not you'll enable paging here. 		;
;	Keep in mind that debugging paging initialization code without the help ;
;	of exception handlers may quickly become a nightmare!					;
;===========================================================================;
	
Once in Kernel Mode:
====================
1. Establish a memory environment and create memory map.
2. Implement a Kernel Mode file system.
3. Start working on device drivers, specifically:
	a. ISA
	b. ATA
	c. PCI
4. One day, add Network Stack support and try adding NE2000 support
5. IRQ's:
	a. one should refrain from having interrupts of different types coming 
	in on the same vector. Common practice is to leave the first 32 vectors 
	for exceptions, as mandated by Intel.